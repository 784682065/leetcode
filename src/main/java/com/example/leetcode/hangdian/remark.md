## 注意事项
1. Main2012 素数判定， 该数开更号，然后i从2 开始到其更号的值被它自己取余。
2. Main2017 主义nextline 与nextInt 公用问题
3. Main2018 奶牛后四年为a[j-1] + a[j-3]= a[j]



4. 2024 ，C语言合法标识符 大小写字母开头，后面为大小写字幕或者下划线或者数字
5. 2026, 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 
      \B匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。

6. 2027 nextInt 与 nextLine共用，中间天加nextLine一次

7. ***2028*** 欧几里得算法，求最小公倍数
1. 涉及到这种问题，必定会有一个求最大公约数的方法，这个方法是什么。
-------欧几里得算法，也就是说辗转相除法，这种算法是求最大公约数，但是最大公约数和最小公约数之间又存在一定的关系。
例如：两个整数num1和num2，求它们之间的最小公倍数，可以利用欧几里得算法（百度百科中讲解得很详细）
```
long result = u;
        //一定要余数为0
        while (u % v != 0) {
            result = u % v;
            u = v;
            v = result;
        }
        return result;
```
，先求出他们的最大公约数GCD，然后，最小公倍数=num*num2/GCD。即可求出。
3、注意，此处需要自己输入需要求最小公倍数的数据。所以，此题是对多个数据求最小公倍数的操作，所以，必须要了解做法：将前两个数的最大公约数和后一个数再次求最大公约数即可。这个操作可以用一个循环控制。 
 


8. Main2030 bys[i] < 0 count++ ; count/2 判断汉字字数
9. Main2035  只需要最后三位数在幂
```
a %= 1000;
int r = 1;
for(int i = 0;i<b;++i){
    r = r*a%1000;
}
```
10.Main2036 ： 面积需要  0.5 * (x1*y2 - x2*y1) 
 https://blog.csdn.net/hemmingway/article/details/7814494
 
11.Main2041
 这是一道典型的递归题目。由于一次只能踏上一级或两级台阶，所以要到达第M级台阶，只有两种方法可以到达，要么从M-1级踏一级，要么从M-2级踏二级。换句话而言，我不管你如何从第一级走到第M-1、M-2级有多少种走法，分别记为f(M-1)、f(M-2)，我只需要知道，
 ```
 f(M) = M-1 + M-2 
 ```
 这两种方法。
 代入得： 
 ```
 f(M) = f(M-1) + f(M-2)
```
hanoi塔递推问题也是这个思路，我不管前面要实现n-1级需要多少步完成，我仅需要知道，要完成第n级，一定只有一种方法，即将处在b桩的第n个塔层先放入c桩，再将a桩的n-1个塔层放入c桩。（题意是，从左向右，a,b,c，最终要放到c桩）

12. Main2043 判断
 ```
 Pattern.compile("[A-Z]").matcher(s).find()
```
 
13.Main 2045 
 递推，f(1)=3,f(2)=6,f(3)=6
２如果有n个方格，当对第n个方格填色时，有两种情况：
１）应该已经对前面n-1个方格填好了色，有f(n-1)种情况，若此时第n-1个跟第一个颜色不一样，第n个只有一种选择。
２）对前面n-2个方格填好色，有f(n-2)种情况，第n-1个空格颜色跟第一个颜色一样（否则就成了上面那种情况了），只有一种可能，最后第n个方格可以填两种颜色（因为n-１和１是第同种颜色），所以是　２*f(n-2);
可以推出f(n)=f(n-1)+2f(n-2),n>=4;
 
 
14. Main2046
 ```
/*
只要简单的推断即可~
假设用arr[i]表示2*i的方格一共有组成的方法数，我们知道arr[1]=1;arr[2]=2;
现在假设我们已经知道了arr[i-1]和arr[i-2],求arr[i],所谓arr[i],不过是在2*（i-1）的格子后边加上一格2*1的方格罢了，骨牌在这一格上横着放，竖着放，如果前面i-1块已经铺好，则第i块只有一种铺法，就是竖着放，如果要横着放，也只有一种铺法，不过要求前面i-2块已经铺好！
因此arr[i]=arr[i-1]+arr[i-2];
*/
```
15. Main 2048 ,全错拍 记住公式f(n)=(n-1)*（f(n-1)+f(n-2)）.
16. Main 2050 , 直线分割公式为 f(n) = f(n-1) + n,而折线分割为 f(n) = f(n -1) + 4 *(n-1) +1  
17. Main2062 https://blog.csdn.net/qq_33266889/article/details/53468509 
18. Main2068 a[i]=(i-1)*(a[i-1]+a[i-2]); 错排公式  
 
##  repractice list
 - 2037
 - 2041
 - 2044 -  50
 - 2056
 - 2058
 - 2059
 - 2062 - 68
 - 2073 2079
 - 2082 